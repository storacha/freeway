import sade from 'sade'
import { getClient } from '@web3-storage/w3cli/lib.js'
import { Space } from '@web3-storage/capabilities'

const cli = sade('delegate-serve.js [space] [token] [accountDID] [gatewayDID]')

cli
  .option('--space', 'The space DID to delegate. If not provided, a new space will be created.')
  .option('--token', 'The auth token to use. If not provided, the delegation will not be authenticated.')
  .option('--accountDID', 'The account DID to use when creating a new space.')
  .option('--gatewayDID', 'The gateway DID to use when delegating the space/content/serve capability. Defaults to did:web:staging.w3s.link.')
  .describe(
    `Delegates ${Space.contentServe.can} to the Gateway for a test space generated by the script, with an optional auth token. Outputs a base64url string suitable for the stub_delegation query parameter. Pipe the output to pbcopy or similar for the quickest workflow. If the GATEWAY_PRINCIPAL_KEY environment variable is not set, a new key pair will be generated.`
  )
  .action(async (space, token, accountDID, gatewayDID, options) => {
    const { space: spaceOption, token: tokenOption, accountDID: accountDIDOption, gatewayDID: gatewayDIDOption } = options
    space = spaceOption || undefined
    token = tokenOption || undefined
    accountDID = accountDIDOption || undefined
    gatewayDID = gatewayDIDOption || 'did:web:staging.w3s.link'
    const client = await getClient()

    let spaceDID
    let proofs = []
    if (!space) {
      const provider = /** @type {`did:web:${string}`} */ (client.defaultProvider())
      const account = client.accounts()[accountDID]
      const newSpace = await client.agent.createSpace('test')
      const provision = await account.provision(newSpace.did(), { provider })
      if (provision.error) throw provision.error
      await newSpace.save()
      const authProof = await newSpace.createAuthorization(client.agent)
      proofs = [authProof]
      spaceDID = newSpace.did()
    } else {
      client.addSpace(space)
      spaceDID = space
      proofs = client.proofs([
        {
          can: Space.contentServe.can,
          with: spaceDID
        }
      ])
    }

    /** @type {import('@ucanto/client').Principal<`did:${string}:${string}`>} */
    const gatewayIdentity = {
      did: () => gatewayDID
    }

    // @ts-expect-error - The client still needs to be updated to support the capability type
    const delegation = await client.createDelegation(gatewayIdentity, [Space.contentServe.can], {
      expiration: Infinity,
      proofs
    })

    await client.capability.access.delegate({
      delegations: [delegation]
    })

    const carResult = await delegation.archive()
    if (carResult.error) throw carResult.error
    const base64Url = Buffer.from(carResult.ok).toString('base64url')
    process.stdout.write(`Agent Proofs: ${proofs.flatMap(p => p.capabilities).map(c => `${c.can} with ${c.with}`).join('\n')}\n`)
    process.stdout.write(`Issuer: ${client.agent.issuer.did()}\n`)
    process.stdout.write(`Audience: ${gatewayIdentity.did()}\n`)
    process.stdout.write(`Space: ${spaceDID}\n`)
    process.stdout.write(`Token: ${token ?? 'none'}\n`)
    process.stdout.write(`Delegation: ${delegation.capabilities.map(c => `${c.can} with ${c.with}`).join('\n')}\n`)
    process.stdout.write(`Stubs: stub_space=${spaceDID}&stub_delegation=${base64Url}&authToken=${token ?? ''}\n`)
  })

cli.parse(process.argv)
